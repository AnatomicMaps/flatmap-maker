#===============================================================================

import pandas as pd
import ast
import json
import os
from pathlib import Path

#===============================================================================

class PathError(Exception):
    pass

#===============================================================================

def generate_aliases(completeness_file, connectivity_term_file):
    df_alias = pd.read_excel(completeness_file, sheet_name='align')
    df_alias = df_alias[df_alias['Selected'].notna()]
    df_alias = df_alias[df_alias['Selected'].astype(str).str.len() > 0]
    
    connectivity_term_file = Path(connectivity_term_file)
    if os.path.exists(connectivity_term_file):
        with open(connectivity_term_file, 'r') as f:
            connectivity_terms = json.load(f)
    else:
        connectivity_terms = []

    current_alias = {}
    for term in connectivity_terms:
        term_id = (term['id'][0], tuple(term['id'][1])) if isinstance(term['id'], list) else term['id']
        if term_id not in current_alias:
            current_alias[term_id] = {
                'id':term_id,
                'name': term.get('name', ''),
                'aliases': [(alias[0], tuple(alias[1])) if isinstance(alias, list) else alias for alias in term['aliases']]
            }

    for idx in df_alias.index:
        alias = df_alias.loc[idx]
        if len(selected:=str(alias['Selected'])) > 0:
            alias_id = ast.literal_eval(selected) if isinstance(ast.literal_eval(selected), tuple) else ast.literal_eval(alias['Align candidates'])
            alias_id = (alias_id[0], tuple(alias_id[1]))
            alias_node = ast.literal_eval(alias['Node'])
            alias_node = (alias_node[0], tuple(alias_node[1]))
            alias_name = '/'.join(ast.literal_eval(alias['Candidate name']))  if alias['Selected'] == '1' else None
            if alias_id in current_alias:
                if alias_node not in current_alias[alias_id]['aliases']:
                    current_alias[alias_id]['aliases'] += [alias_node]
            else:
                current_alias[alias_id] = {
                    'id': alias_id,
                    'aliases': [
                        alias_node
                    ]
                }

            if alias_name is not None:
                current_alias[alias_id]['name'] = alias_name

    with open(dest:=connectivity_term_file.parent/f"generated-{connectivity_term_file.name}", 'w') as f:
        json.dump(list(current_alias.values()), f, indent=4)

    print(f'The generated connectivity_terms is available at: {dest}')

def main():
    import argparse
    import sys

    parser = argparse.ArgumentParser(description="Checking nodes and edges completeness in the generated flatmap")
    parser.add_argument('--completeness-file', dest='completeness_file', metavar='COMPLETENESS_FILE', help='Missing node alignment file that is already curated')
    parser.add_argument('--connectivity-terms-file', dest='connectivity_term_file', help='The connectivity terms file that will be merged with the aligned file')
    
    try:
        args = parser.parse_args()
        generate_aliases(args.completeness_file, args.connectivity_term_file)
    except PathError as error:
        sys.stderr.write(f'{error}\n')
        sys.exit(1)
    sys.exit(0)

#===============================================================================

if __name__ == '__main__':
    main()

#===============================================================================

# This script is used to merge the currated align missing node to the existing connectivity_terms.json
# Command:
# python ./npo_alias.py --completeness-file `the aligned file generated by npo_align.py and has been curated`
#                       --connectivity-terms-file `connectivity_terms file to merge`